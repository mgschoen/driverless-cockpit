<link rel="import" href="./fsd-map-imports.html">

<link rel="import" href="fsd-map-converter.html">

<dom-module id="fsd-map">
  <template>
    <style>

      :host {
        display: block;
        height: 500px;
      }

    </style>

    <div id="canvas"></div>

  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
    class fsdMap extends Polymer.Element {
      static get is() {
        return 'fsd-map';
      }

      static get properties() {
        return {
          // Program logic internals
          componentReady: { type: Boolean, value: false },
          converter: Object,

          // raw vehicle data
          steerAngle: { type: Number, value: 0.0 },
          pathMiddleX: { type: Number, value: 0.0 },
          pathMiddleY: { type: Number, value: 0.0 },
          vehicleX: { type: Number, value: 0.0 },
          vehicleY: { type: Number, value: 0.0 },

          // transformed vehicle data
          __pathMiddleX: { type: Number, computed: '_transformMeter(pathMiddleX)' },
          __pathMiddleY: { type: Number, computed: '_transformMeter(pathMiddleY)' },
          __vehicleX: { type: Number, computed: '_transformMeter(vehicleX)' },
          __vehicleY: { type: Number, computed: '_transformMeter(vehicleY)' },

          // render objects
          stage: Object,
          baseLayer: Object,
          shapeVehicle: Object,
          shapeTrack: Object,
          shapeMiddlePath: Object,

          // animations
          animationStage: Object,
          animationVehicle: Object,
          animationTrack: Object,
          animationMiddlePath: Object,

          // view parameters
          dragActive: { type: Boolean, value: false },
          __dragListenerFunction: { type: Object },
          zoomStep: { type: Number, value: 1.1, readOnly: true },
          minZoomScale: { type: Number, value: 0.15, readOnly: true},
          maxZoomScale: { type: Number, value: 5.0, readOnly: true },

          // view controls
          showVehicle: { type: Boolean },
          showTrack: { type: Boolean },
          showMiddlePath: { type: Boolean },
          focusVehicle: { type: Boolean, observer: '_focusVehicleChanged' }
        };
      }

      static get observers() {
        return [
          '_showParametersChanged(showVehicle, showTrack, showMiddlePath)'
        ];
      }

      ready() {
        super.ready();

        // Initialise converter component
        this.converter = new fsdMapConverter();

        // Initialise Konva app
        var canvas = this.shadowRoot.querySelector('#canvas');
        this.stage = new Konva.Stage({
          container: canvas,
          width: this.offsetWidth,
          height: 500
        });

        // create base layer
        this.baseLayer = new Konva.Layer();
        this.stage.add(this.baseLayer);

        // draw middle path
        this.shapeMiddlePath = new Konva.Line({
          points: [],
          stroke: '#323232',
          strokeWidth: this.converter.meterToPixels(3)
        });
        this.baseLayer.add(this.shapeMiddlePath);

        // draw vehicle track
        this.shapeTrack = new Konva.Line({
          points: [],
          stroke: '#ffffff',
          strokeWidth: 4
        });
        this.baseLayer.add(this.shapeTrack);

        // draw vehicle
        var vehicleImage = new Image();
        vehicleImage.onload = function () {
          this.shapeVehicle = new Konva.Image({
            image: vehicleImage,
            width: this.converter.meterToPixels(2.925),
            height: this.converter.meterToPixels(1.395),
            offsetX: this.converter.meterToPixels(2.925) / 2,
            offsetY: this.converter.meterToPixels(1.395) / 2
          });
          this.baseLayer.add(this.shapeVehicle);
        }.bind(this);
        vehicleImage.src = '/static/pwd.png';

        // add animations
        this.animationMiddlePath = new Konva.Animation(this._animateMiddlePath.bind(this), this.baseLayer);
        this.animationTrack = new Konva.Animation(this._animateTrack.bind(this), this.baseLayer);
        this.animationVehicle = new Konva.Animation(this._animateVehicle.bind(this), this.baseLayer);
        this.animationStage = new Konva.Animation(this._animateStage.bind(this), this.baseLayer);

        // start animations
        this.animationMiddlePath.start();
        this.animationTrack.start();
        this.animationVehicle.start();
        if (this.focusVehicle) {
          this.animationStage.start();
        }

        // initialise zoom
        this.stage.attrs.container.addEventListener('mousewheel', this._performZoom.bind(this));
        this.stage.attrs.container.addEventListener('wheel', this._performZoom.bind(this));

        // add drag listeners
        this.stage.attrs.container.addEventListener('mousedown', this._startDrag.bind(this));
        this.stage.attrs.container.addEventListener('mouseup', this._stopDrag.bind(this));
        this.stage.attrs.container.addEventListener('mouseleave', this._stopDrag.bind(this));
        this.__dragListenerFunction = this._dragStep.bind(this);

        // add resize listener
        window.addEventListener('resize', function () {
          this.stage.width(this.offsetWidth);
        }.bind(this));
      }

      _performZoom (e) {
        e.stopPropagation();
        e.preventDefault();

        // gather parameters
        let oldScale = this.stage.scaleX();
        let mouseTarget = {
          x: this.stage.getPointerPosition().x / oldScale - this.stage.x() / oldScale,
          y: this.stage.getPointerPosition().y / oldScale - this.stage.y() / oldScale
        };

        // scale stage
        let delta = e.wheelDeltaY || -e.deltaY;
        let computedScale = delta > 0 ? oldScale * this.zoomStep : oldScale / this.zoomStep;
        let newScale =
                (computedScale < this.minZoomScale) ? this.minZoomScale :
                (computedScale > this.maxZoomScale) ? this.maxZoomScale :
                computedScale;
        this.stage.scale({ x: newScale, y:  newScale});

        // move stage to mouse position
        let newPos = {
          x: -(mouseTarget.x - this.stage.getPointerPosition().x / newScale) * newScale,
          y: -(mouseTarget.y - this.stage.getPointerPosition().y / newScale) * newScale
        };
        this.stage.position(newPos);
        this.stage.batchDraw();
      }

      _startDrag (e) {
        if (!this.dragActive) {
          this.dragActive = true;
          this.stage.attrs.container.addEventListener('mousemove', this.__dragListenerFunction);
        }
      }

      _stopDrag (e) {
        if (this.dragActive) {
          this.dragActive = false;
          this.stage.attrs.container.removeEventListener('mousemove', this.__dragListenerFunction);
        }
      }

      _dragStep (e) {
        this.stage.move({ x: e.movementX, y: e.movementY });
        this.stage.batchDraw();
      }

      _showParametersChanged (showVehicle, showTrack, showMiddlePath) {
        if (this.shapeVehicle) {
          showVehicle
                  ? this.shapeVehicle.show()
                  : this.shapeVehicle.hide();
        }
        if (this.shapeTrack) {
          showTrack
                  ? this.shapeTrack.show()
                  : this.shapeTrack.hide();
        }
        if (this.shapeMiddlePath) {
          showMiddlePath
                  ? this.shapeMiddlePath.show()
                  : this.shapeMiddlePath.hide();
        }
      }

      _transformMeter (m) {
        return (this.converter) ? this.converter.meterToPixels(m) : 0.0;
      }

      _animateMiddlePath () {
        let points = this.shapeMiddlePath.points();
        let last = {x: points[points.length - 2], y: points[points.length - 1] };
        if (this.__pathMiddleX != last.x || this.__pathMiddleX != last.y) {
          if (points.length >= 2 && points[0] == 0 && points[1] == 0) {
            points.shift(); points.shift(); console.log('Removed origin from middle path');
          }
          this.shapeMiddlePath.points(points.concat([this.__pathMiddleX, this.__pathMiddleY]));
        }
      }

      _animateTrack () {
        let points = this.shapeTrack.points();
        let last = {x: points[points.length - 2], y: points[points.length - 1] };
        if (this.__vehicleX != last.x || this.__vehicleY != last.y) {
          if (points.length >= 2 && points[0] == 0 && points[1] == 0) {
            points.shift(); points.shift(); console.log('Removed origin from track');
          }
          this.shapeTrack.points(points.concat([this.__vehicleX, this.__vehicleY]));
        }
      }

      _animateVehicle () {

        if (this.shapeVehicle) {
          this.shapeVehicle.x(this.__vehicleX);
          this.shapeVehicle.y(this.__vehicleY);

          let points = this.shapeTrack.points();
          if (points.length >= 4) {
            let next2Last = {
              x: points[points.length - 4],
              y: points[points.length - 3]
            };
            let last = {
              x: points[points.length - 2],
              y: points[points.length - 1]
            };
            let dir = {
              x: last.x - next2Last.x,
              y: last.y - next2Last.y
            };
            let dirLength = Math.sqrt(Math.pow(dir.x,2) + Math.pow(dir.y,2));
            let cosine = dir.x / dirLength;
            let degree = Math.acos(cosine) * (180 / Math.PI);
            this.shapeVehicle.rotation((dir.y >= 0) ? degree : (360 - degree));
          }
        }
      }

      _focusVehicleChanged (focusVehicle) {
        if (this.animationStage) {
          if (focusVehicle) {
            this.animationStage.start();
          } else {
            this.animationStage.stop();
          }
        }
      }

      _animateStage () {
        if (this.stage && this.shapeVehicle) {
          let scale = this.stage.scaleX();
          let canvas = { x: this.stage.width(), y: this.stage.height() };
          let absoluteCarpos   = { x: this.shapeVehicle.x(), y: this.shapeVehicle.y() };
          let onscreenCarpos   = { x: absoluteCarpos.x * scale, y: absoluteCarpos.y * scale };
          let camTranslation   = { x: this.stage.x(), y: this.stage.y() };
          let onscreenCampos   = { x: -camTranslation.x, y: -camTranslation.y };
          let onscreenCamFocus = { x: onscreenCampos.x + canvas.x/2, y: onscreenCampos.y + canvas.y/2 };
          let onscreenDist     = { x: onscreenCarpos.x - onscreenCamFocus.x, y: onscreenCarpos.y - onscreenCamFocus.y };
          this.stage.move({ x: -onscreenDist.x, y: -onscreenDist.y });
        }
      }
    }

    window.customElements.define(fsdMap.is, fsdMap);
  </script>
</dom-module>
